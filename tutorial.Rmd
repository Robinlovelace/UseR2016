---
layout: post
title:  "Handling and Analyzing Spatial, Spatiotemporal and Movement Data"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
comments: true
author: Edzer Pebesma
output:
  html_document:
      toc: true
      theme: united
---

The source R-Markdown (.Rmd) file for this document is found [here](https://raw.githubusercontent.com/edzer/UseR2016/master/tutorial.Rmd)

# Introduction
Two quotes from [Cobb and Moore, 1997](http://www.jstor.org/stable/2975286),
 
> _Data are not just numbers, they are numbers with a context_
 

and
 

> _in data analysis, context provides meaning_

 
illustrate that data analysis without context is essentially meaningless. What is context? We can think of

* _who_ collected or generated the data,
* _how_ were the data collected (e.g., by which sampling strategy?),
* for which purpose were the data collected, or generated (_why_)
* _when_ and _where_ were the data collected
* _what_ exactly was collected, what do the values refer to, what are measurement units, and what does the value `1` refer to?

We can think of the _who, how_ and _why_ question referring to
pragmatics of data collection, where _when, where_ and _what_
refer to data semantics.

## Time in R

Base R has some infrastructure to annotate measurement units, in particular for time and date information:
```{r}
now = Sys.time() + c(0, 3600)
today = Sys.Date() + 0:1
```
which represent numeric values pointing to the number of seconds or days elapsed since Jan 1, 1970, 00:00 UTC:
```{r}
as.numeric(now)
as.numeric(today)
```
The `class` attribute of these objects
```{r}
class(now)
class(today)
```
make it behave meaningfully like time:
```{r error=TRUE}
now * now
now + now
(dt = now[2] - now[1])
```

## Time differences

This last quantity, `dt` has a class 
```{r}
class(dt)
```
but also a `units` attribute, which can be retrieved by the `units` method:
```{r}
units(dt)
```
but can also be set to other values, e.g.
```{r}
units(dt) = "days"
dt
units(dt) = "secs"
dt
```

## Measurement units
Beyond time and time differences, more general support for [SI
units](https://en.wikipedia.org/wiki/International_System_of_Units)
and derived units is provided by CRAN package
[units](http://cran.r-project.org/package=units), which builds upon
CRAN package [udunits2](http://cran.r-project.org/package=udunits2)
and the external [udunits](https://www.unidata.ucar.edu/software/udunits/) 
library, from [UNIDATA](https://www.unidata.ucar.edu/).
It checks compatibility of units, does unit conversion on the fly
```{r}
library(units)
x = as.units(1:3, "m/s")
xkmh = x
units(xkmh) = "km/h"        # explicit conversion
xkmh
(y = as.units(1:3, "km/h")) # something different
x + y                       # implicit conversions
y + x
c(x, y)
```
it creates derived units where appropriate
```{r}
x * y
x / y
log(x)
```
and also gives meaningful warnings when units are not compatible:
```{r error=TRUE}
x + x * y
```
as udunits parses units, they can become arbitrarily complex:
```{r}
u1 = paste0(rep("m", 100), collapse = "*")
u2 = "m^100"
as.units(1:3, u2) + as.units(1:3, u1)
```
[units](http://cran.r-project.org/package=units) nicely
integrates with `data.frame` objects and even better with
[dplyr](http://cran.r-project.org/package=dplyr):
```{r}
library(dplyr)
x = filter(mtcars, cyl == 8)
(x1 <- x %>% mutate(mpg = as.units(mpg, "miles/gallon")) %>% head(2))
x1 %>% mutate(kmpl = as.units(mpg, "km/l")) %>% tbl_df %>% select(c(1, 12))
```

Summarizing, measurement units

* convert units explicitly, or implicitly/on the fly
* catch operations that are algebraically correct but _physically meaningless_
* help carry out [dimensional analysis](https://en.wikipedia.org/wiki/Dimensional_analysis)

and provide, in that sense, part of the context of data.

## Why don't we treat space and time as special cases of SI units?

Measures of physical quantities such as length, mass, duration have
a natural, absolute zero value. When measuring absolute time (when)
and location (where), we need a reference. 

For time, we have Coordinated Universal Time
([UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time));
different time zones and DST rules are defined with respect to UTC.

For space, different [geodetic
datums](https://en.wikipedia.org/wiki/Geodetic_datum)
exist; the best known being the
[WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System)
ellipsoid (``world geodetic system-1984'')

WGS84 is a _global_ reference system, and has larger errors
(deviations from the geoid, the `mean sea level' surface) than
ellipsoids that are fitted locally. For that reason, local ellipsoids
might better fit the Earth locally, and are prefered for particular
surveying projects. Coordinate _transformations_ move from one
geodetic datum (ellispoid) to another; these transformation may be
non-unique, non-invertible, and approximate.

Projecting longitude/latitude degrees to a flat representation
(such as UTM, or Web Mercator) is called coodinate _conversion_;
this process is usually accurate and invertible.

## When are space and time _not_ relevant?

For a doctor, the identity and age of the patient are more relevant
than the location of the patient and date of the examination.
An MRI scan of a patient's brain is understood _with reference to_
the skull and other reference points, not with reference to the
geographical location f the MRI scanner.

Many data sets come without information about space and time; this
usually indicates that these aspects were not considered relevant.
For the `co2` dataset,
```{r}
plot(co2)
```

the location of measurements ([Mauna
Loa](https://en.wikipedia.org/wiki/Mauna_Loa)) can be derived from
the URL mentioned in `?co2`, or even better, from the information
the URL points to. For the `mtcars` dataset, `?mtcars` reveals when
the car models described were current (1973-4).

# Time series data

We have seen so far mostly time information, but not information
that is associated with time, or _time series data_.

## Classes for time series data

The `co2` data set is an example of this, as a time series:
```{r}
class(co2)
summary(co2)
```

The `ts` class, part of base R, accomodates for regular time series, and does
not use `POSIXt` for time:
```{r}
attributes(co2)
```
Many of the methods for `ts` do not deal well with semi-regular time series,
which are regular but contain missing values.

Approaches to deal with irregular time series are found in
packages [its](http://cran.r-project.org/package=its),
[zoo](http://cran.r-project.org/package=zoo) and
[xts](http://cran.r-project.org/package=xts). Package xts
builds on `POSIXt` as the time index, and extends `zoo`. The
combination has nice features for

* selection, supporting [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) strings for time periods
* aggregation, using functions that cut time in particular intervals

What follows is an example where the string "2000:2007" selects all
data for these three years, and the `aggregate` method (from `zoo`)
uses the function `as.yearmon` to cut a time period into months,
convert these into years, and to compute yearly averages:
```{r}
data(air, package = "spacetime")
library(zoo)
library(xts)
pm10 = xts(t(air), dates)
as.year <- function(x) as.numeric(floor(as.yearmon(x)))
plot(aggregate(pm10["2000::2007", 1], as.year, mean, na.rm = TRUE),
	ylab = "PM10 (ppm)")
title("Yearly averaged PM10 values, 2000-2007")
```

## Extensive or intensive properties?

Physical properties can be [extensive or
intensive](https://en.wikipedia.org/wiki/Intensive_and_extensive_properties),
depending on whether the property changes when the size (extent)
of the system changes: 

* exptensive properties are for instance mass and size: if we cut a rock into pieces, mass and size of a piece change 
* intensive properties are e.g. temperature or density; these do not necessarily change with size

In the aggregation example above, we computed the yearly _mean_ values,
but when examining `?aggregate.zoo`, we'd find out that the default aggregation
function is `sum`, so
```{r}
a = aggregate(pm10["2000::2007", 1], as.year, na.rm = TRUE)
mean(a)
```
computes yearly _total_ pm10, from monthly averages, which is not
physically meaningful for an intensive property like pm10.

## Events, continuous series, aggregations?

Time series data, as represented by the packages mentioned above,
do not distinguish events from continuous processes: ``values''
of something are simply associated with a time stamp. Yet, for
meaningful analysis, their difference could not be larger:

* for events, we can compute counts, or densities over time, but we cannot interpolate; for instance, the temporally interpolated value of earthquake magnitudes for a moment with no earthquake does not make sense
* for continuous processes,  counts or densities only reveal properties of the sampling procedure, and not of the observed phenomenon (which could have been observed any moment)

Many time series data (`co2` and `pm10` above being two examples)
concern temporally aggregated values. Yet, their value is not
explicitly registered with the aggregation period, but rather with
the starting time of this interval. If, however, instantaneous
measurements of the same variables would be available (co2 or
pm10 measured at the start of the month), they would be stored
identically.  If time periods would be registered explicitly,
we would in addition have to specify how the associated (co2,
pm10) value relates to this interval, possibilities are:

* the value is constant throughout this interval
* the value was aggregated over this interval (in which case the aggregation _function_ needs to be specified)

# Spatial data

## Classes for spatial data

A large majority of spatial data constitute, roughly, of points,
lines, polygons or grids. As described in [Bivand, Pebesma
and Gomez-Rubio (2013)](http://asdar-book.org/), package
[sp](http://cran.r-project.org/package=sp) provides basic
infrastructure for this, and supports the following classes:

![](spatial.png)

The geometry-only classes, `SpatialXxx`, derive from `Spatial` and
share a bounding box and coordinate reference system (`proj4string`);
all the `SpatialXxxDataFrame` classes extend this with a `data.frame`
carrying attributes associated with the geometries.

Important reasons why many think that using `sp` is a good idea include:

* reinventing the wheel too often creates duplicate work, and calls for many-to-many conversions
* through [rgdal](http://cran.r-project.org/package=rgdal), `sp` supports reading and writing to and from all 142 [raster](http://gdal.org/formats_list.html) and 84 [vector](http://gdal.org/ogr_formats.html) formats supported by [GDAL](http://www.gdal.org/)
* through [rgeos](http://cran.r-project.org/package=rgeos), `sp` objects can be used for all [DE-9IM](https://en.wikipedia.org/wiki/DE-9IM) intersections, including topological predicates like _touches_, _overlaps_, _intersects_, _contains_, etc., and also create buffers, unite polygons etc.

## An example: why polygons are complex

`Single' geometry entries for polygons and lines can consist of
multiple polygons or lines, to accomodate real-word data. In the following
example we see a state consisting of multiple polygons, one of them 
containing a hole:
```{r}
data(air, package = "spacetime")
library(sp)
nds = DE_NUTS1["Niedersachsen",]
library(ggmap)
bgMap = get_map(as.vector(bbox(nds)), source = "google", zoom = 7)
par(mar = rep(0,4))
merc = CRS("+init=epsg:3857")
plot(spTransform(nds, merc), bgMap = bgMap, col = grey(.5, alpha = .5))
```

We can examine the data interactively, thanks to the excellent 
[mapview](http://cran.r-project.org/package=mapview) package:
```{r}
library(mapview)
mapview(nds)
```

When properly plotting data, we need to know which
hole polygon belongs to which enclosing polygon, and
this makes it difficult (if not impossible) to encode
polygons in simple tables such as propagated by the [tidy
data](https://www.jstatsoft.org/article/view/v059i10)
framework.  The `fortify` method in
`ggplot2` destroys this structure, and the [ggplot2
wiki](https://github.com/hadley/ggplot2/wiki/plotting-polygon-shapefiles)
explains why `ggplot2` cannot properly plot polygons with holes.

In the plot above, we can see that the border of `nds` does not correspond very well
with that of [openstreetmap](http://www.openstreetmap.org/). This may be due to an
outdated version of `DE_NUTS1` in the `spacetime` package.

### Exercise

1. visit [gadm](http://gadm.org/)
1. download the German administrative boundaries as a shapefile from gadm.org
1. unzip the files starting with `DEU_adm1`, and register in which directory they are 
1. read them in with `library(rgdal); x = readOGR(".", "DEU_adm1")`, where you replace `.` with the right directory
1. plot Lower Saxony with mapview (`mapview(x[9,])`)
1. check whether the Dutch/German boundaries are better, now.

## Selecting features

As we've seen above, we can use the `[` subset operator on `Spatial` objects to select
geometries/features (rows), or particular attributes, similar
to how this is done for `data.frame` objects. Further functionality
is obtained when we use a `Spatial` object as selector, as in
```{r}
par(mar = c(4,4,4,1))
plot(DE_NUTS1[nds,], col = grey(.9), axes = TRUE) # all states touching Lower Saxony;
plot(nds, col = grey(.5), add = TRUE) # .. which is grey.
```

this carries out an intersection, and returns intersecting
geometries, for _any Spatial object type_.

# Spatiotemporal data, movement data

## Class structure

# Importing spatial and temporal data

## from tables

## form shapefiles

## from web services

# Spatial data classes in [sp](http://cran.r-project.org/package=sp)

# Spatiotemporal data in [spacetime](http://cran.r-project.org/package=spacetime)

# Trajectory data in [trajectories](http://cran.r-project.org/package=trajectories)

## plotting

## aggregation

* import spatial, temporal, and spatiotemporal data in R
* map these data structures to and from matrix and data.frame objects
* work with time series of each of these
* work with space-time events, and moving objects
* intersect various spacetime objects, e.g. for spatial and/or temporal selection or for spatial, temporal or spatiotemporal aggregation
* represent higher concepts such as fields, objects, events, trajectories, and aggregations into the classes, and how to carry out meaningful analysis of these


# sessionInfo()
```{r}
sessionInfo()
```
